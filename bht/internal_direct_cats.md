### A strategy for implementing type-valued diagrams on (certain) inverse categories <br/> A.k.a.: A generalisation of the bht approach

Everything described in Sieves.agda can be done in higher generality. And maybe
that's actually easier to implement? For simplicity, I'll talk about *direct*
(as opposed to *inverse*) categories, i.e. arrows only "go up"as in Δ+ (before
taking the dual).

Definition (ordered, locally Bishop finite, direct category).
Consider a category I with objects ℕ, given by
   Hom : ℕ → ℕ → Set
and the usual structure (composition, associativity, identities).
(a) I is *direct* if
      m < n → Hom n m = ∅
      Hom m m = ⊤
    ("non-id arrows only go up")
(b) I is *locally Bishop-finite* if
      (m n : ℕ) → Σ(k : ℕ). (Hom m n) ≃ Fin k
    ("every homset is finite with explicit decidable total order")
(c) Let I be locally finite in the sense of (b). The iso (Hom m n) ≃ Fin k
    induces a total order < on every homset.
    I is *monotone* if, for every morphism f, post-composition with f is
    monotone,
      (f : Hom m n) (g h : Hom k m) → g < h → f ∘ g < f ∘ h
    ("every Yoneda(f) is monotone")
I is an *ordered, locally Bishop-finite, direct category* if it satisfies (a-c).

Note. Direct categories are "the same" as direct semicategories since the
identities don't do anything.

Example. Δ₊ is the guiding example, with lexicographic order on the homsets.

(
Lemma (not very important for now). For any locally Bishop-finite direct
category, we can change the isos with Fin k to make it ordered.
Proof. Should work but I haven't checked it.
)

From now on, assumed that I is an ordered, locally Bishop-finite, direct
category. Let b be an object in I. We want to talk about subfunctors of
Yoneda(b); equivalently, we can talk about *sieves* on b. We could use either
terminology. A *sieve* S on b is simply a set of morphisms with codomain b that
are closed under pre-composition, i.e. g ∈ S → g ∘ f ∈ S

Definition. For a given object b of I, a *starting sieve* (a.k.a. bht sieve) is
given by an object h (typically h < b) and t ∈ 1 ⊎ Hom h b. This is given by:

Construction:
From the pair (h,t), we get a concrete sieve S(h,t) on b as follows:
∙ for k < h, every g ∈ Hom k b is in the sieve;
∙ for k = h, a g ∈ Hom k b is in the sieve iff g ≤ t
             (with (inl *) minimal in 1 ⊎ Hom h b)
∙ for k > h, no g ∈ Hom k b is in the sieve


Definition (standard, a reference is MacLane-Moerdijk, "Sheaves in geometry
and logic", chapter I.4, p 38). If S is a sieve on b and f ∈ Hom m b, then
  S ∙ f = {h | f ∘ h ∈ S}
is a sieve on m.

Remark. I (Nicolai) have previously talked about the intersection of S and the
"principle" sieve generated by f, but the above is probable the more direct
definition. In Agda, we still want to define it in the way it's implemented
right now, so this is only a "comment-level" terminology change.

Lemma. If b is an object as above, with (h,t) determining a starting sieves
S(h,t), and f ∈ Hom m b is a morphism as above, then
  S(h,t) ∙ f
is a starting sieve on m, i.e. can be represented by (h', t').

Proof.
It's not difficult to describe what S' := S(h,t) ∙ f ⊆ ⋃_(k ≤ m) (Hom k m) is.
For...
∙ k < h, every g ∈ Hom k m is in S'
∙ k = h, a g ∈ Hom k m is in S' iff f ∘ g ≤ t
∙ k > h, no g ∈ Hom k m is in S'.
Because of the monotonicity condition on the category I (point c of first
definition in this file), this is a starting sieve on m, with h' := h and
t' = (the maximal s ∈ Hom h m such that f ∘ h ≤ t).

Caveat: In the Agda implementation, the definition of ∩ is correct because of
the above lemma. The above lemma justifies the definition of [b,h,t]∩f by
recursion on t as described in Sieves.agda.

([unimportant]
Notes. Maybe we should only use finite direct/inverse categories (instead of
what are essentially finite sieves of inverse categories)?
Maybe "well-presented" would be better terminology.
)

### Note

Terminology: A type is called "small" if it is in the (lowest or only) universe.

If (Con, Sub, Ty, Tm) is a CwF with a universe U, then there's a "smaller" CwF (or a sub-CwF) which only consists of small types and contexts (small context = context build of U and small types).

What we're doing above is not the construction of contexts in Shulman's paper, but we're constructing (with SST n) the limit of the universe in the model of the new CwF.

See also the [discussion on the FP Zulip](https://fplab.zulipchat.com/#narrow/stream/122461-general/topic/Shulman's.20universe.20construction/near/263715906).

### Extending the Construction: From Contexts to CwF's?

Denote the original CwF by (Con, Sub, Ty, Tm). Denote the empty context by ●.
Given inverse category I = (Δ₊)op(≤n) as above, the above constructs a context
(SST n) : Con, from now for simplicitly called SST : Con. If the inverse
category I is *not* (Δ₊)op, it should be called differently, but let's ignore
this for now and still call it SST : Con.

If I → J is a sieve embedding of inverse cats, there
is a substitution Sub SST_J SST_I, so what we've constructed is essentially
a functor

  InvSieveEmb → (Con,Sub).

This is the induced functor between limits.

Where exactly do we want to go from here? If we want to build a CwF,
we could define:

* A new context Con' by Con' := Sub ● SST

* For Γ,Δ : Con', a substitution in Sub' Γ Δ is given by a substitution
  α : Sub SST SST such that α ∘ Γ = Δ

* Assuming I is the inverse cat, we can take I × 2 (with 2 the walking arrow)
  and take SST(I × 2) as the total space of Ty'(I) over Con'(I).

